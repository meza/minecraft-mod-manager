# Over-The-Air Self-Updates for a Go CLI Application

## Overview
Implementing over-the-air (OTA) updates in a Go command-line tool can be achieved through libraries that handle checking for new releases and replacing the running binary. The goal is to have the single executable detect a newer version (from GitHub Releases) and **self-update without user intervention**. Below we outline several **libraries and approaches** for Go self-updating binaries, along with important considerations like cross-platform support, update frequency, asset naming, and security.

## Libraries Leveraging GitHub Releases for Self-Update

- **creativeprojects/go-selfupdate (fork of rhysd/go-github-selfupdate):** This popular library uses the GitHub Releases API to detect the latest version (by Git tag) and fetch the appropriate OS/arch binary asset. It expects release assets to follow a naming convention of `<command>_{GOOS}_{GOARCH}[.ext]` (e.g. `myapp_linux_amd64.tar.gz`, `myapp_windows_amd64.zip`). Archives (`.zip`, `.tar.gz`, etc.) are supported, and the library will extract and replace the current executable in place. Pre-releases and non-semver tags are ignored to ensure only stable semantic versions trigger updates. This library works on Linux, macOS, Windows, etc., and handles finding the correct asset and updating the binary atomically.

- **mouuff/go-rocket-update:** A newer, modular library that supports multiple “provider” backends (GitHub, GitLab, local files, etc.) for updates. Using the GitHub provider, it will check the latest GitHub release for a specified asset name (you define the archive naming scheme). You configure the updater with the repository, the current version, the expected binary name pattern, and it will download and replace the executable if a newer version is found. It’s cross-platform and designed for flexibility – for example, you can fall back to another source if GitHub is down, or use a local file for testing. *Note:* Ensure the binary has write permission in its install location (if the app is in a protected directory like Program Files, admin rights are needed to overwrite it). The project is under active development (as of 2025) with planned features like update channels and binary validation.

- **blockthrough/selfupdate.go:** A toolkit that integrates tightly with GitHub Releases and GitHub Actions to streamline the update process. It provides both a CLI tool and an SDK library for self-updating. The CLI can automate release creation, asset upload (with optional signing), and version checks as part of your CI pipeline. In your application, the SDK can check GitHub for a new version and download it. This toolchain emphasizes ease of use for maintainers by leveraging GitHub’s APIs and is useful if you want a built-in signing and CI workflow for publishing updates. (Given its focus on GitHub Action integration, it assumes you tag releases and optionally provide a signature for each asset during CI.)

## Other Self-Update Libraries and Options

- **sanbornm/go-selfupdate:** An earlier solution inspired by Chrome’s updater, allowing Go apps to update from a custom HTTP server or S3 bucket. Instead of GitHub releases, you host a JSON manifest and binary files. It supports **binary diff patches** via bsdiff so that updates can be smaller incremental downloads. If a diff fails or is unavailable, it falls back to full binary replacement. You’d generate patch files for each release (the tool provides a utility to do so) and serve them along with a manifest. This approach gives fine control (and works offline or on private networks), but requires you to maintain the update server and doesn’t natively integrate with GitHub’s release system. It’s tested on Windows, macOS, Linux (including ARM) and widely used in some older projects.

- **inconshreveable/go-update (and forks minio/selfupdate, fynelabs/selfupdate):** This is a low-level library that handles the **mechanics of replacing the running binary** safely, with optional cryptographic verification. Minio’s fork in particular is used in their products and adds enhancements for security. With these, your program manually fetches the new version (from any URL or source) and then calls an `Apply()` function to patch or replace itself. Notably, these provide **checksum and signature verification** of updates and can apply binary patches (to reduce download size) if you supply a diff file. For example, minio/selfupdate can verify a digital signature (minisign/ed25519) before applying an update, and fynelabs’ selfupdate requires you to configure an Ed25519 public key in the app – it will only apply updates signed with the corresponding private key. These libraries give you strong security (protecting against tampered updates) and even support updating arbitrary files, but you are responsible for hosting the update files and providing the URLs. They are a good choice if you need **maximum control or offline updates**, or want to implement a custom update logic (e.g. your app checks an API or file and then uses `selfupdate.Apply()` to install the new binary).

- **The Update Framework (TUF) approach:** For the highest level of security and trust, some projects have adopted TUF to distribute signed update metadata. This is more complex, but it defends against many attacks. For example, Foundries.io’s *fioctl* CLI publishes TUF metadata in a GitHub branch and uses the **go-tuf** library to check for updates securely. In this model, the client downloads signed metadata (e.g. a `targets.json`) that lists the latest version and hashes of the release binaries, verifies it using embedded public keys, then downloads the asset and verifies its hash before replacing itself. While highly secure, implementing TUF requires significant setup (managing keys, rotating metadata, running update signer workflows). For most projects, a simpler library like those above (possibly combined with signature verification) is sufficient, but it’s good to know this option exists for mission-critical applications.

## Implementation Considerations

- **Version Checking Frequency:** You indicated you want to check for updates on **every run** of the application. All the libraries above support on-demand checks (e.g., at startup). Be mindful of rate limits if using the GitHub API frequently – using unauthenticated requests to GitHub’s API has a limit (60 per hour), which is usually fine for daily use. For heavier usage, consider bundling a GitHub token or prompting the user to set one, or check less often (e.g. once a day) and cache the result.

- **Release Tagging and Naming:** To use GitHub-based updaters, follow a consistent versioning scheme. Tools like go-selfupdate assume semantic version tags (like `v1.2.3`) for comparing versions. Name your release assets predictably per OS/arch. For example, with goreleaser you can configure file names like `myapp_linux_amd64.tar.gz`, `myapp_windows_amd64.zip`, etc., which matches the expectations of go-selfupdate. The updater will pick the correct asset for the current runtime OS and architecture. In go-rocket-update, you manually specify the pattern (e.g. `binaries_{{OS}}.zip` in the example). Ensure every release includes all the necessary binaries as assets.

- **Self-Replacement Mechanics:** These libraries download the new binary and **replace the current executable file**. Typically, the process is: write to a temp file, verify integrity (if enabled), then swap the files. This means the CLI can update itself without an external installer. Since your app is a single portable executable, this fits well. Just make sure the process has permission to write to its install location. If the user put the binary in a privileged path (like `/usr/local/bin` or `%ProgramFiles%`), the update might fail without sudo/Administrator rights. In portable scenarios (user’s home directory or a custom tools folder), there should be no issue. After replacement, some libraries can restart the process automatically or you may need to prompt the user to restart the tool for the new version to take effect.

- **Security Best Practices:** Silent auto-updates carry some risk, so consider at least basic verification. All communication should occur over HTTPS to prevent tampering in transit. For additional safety, you can use libraries that support **checksum or signature verification** of the downloaded binary. For example, the minio and fynelabs libraries support out-of-the-box signature checking (Ed25519 or Minisign). If you opt not to implement signing now, at minimum you might verify a checksum from a trusted source. In any case, communicate in your docs that the tool auto-updates, and perhaps provide a flag to disable auto-update if some users prefer manual control. This transparency can build trust, especially if you are not yet signing releases.

- **Delta Updates vs Full Downloads:** You mentioned being open to skipping delta (patch) updates if it simplifies things. Indeed, most modern solutions (go-selfupdate, go-rocket-update, etc.) simply download the full new binary for simplicity. If your binary is reasonably sized, this is usually fine. The sanbornm approach and go-update forks can do binary diffs to minimize download size, but that requires generating patch files for each version jump and can complicate the release process. Many maintainers find the trade-off of a slightly larger download worth the simplicity of a full replacement. You can always add diff updates later if needed.

In summary, **the easiest path** for a GitHub-hosted project is to use a library like *creativeprojects/go-selfupdate* or *mouuff/go-rocket-update*, which will handle checking GitHub Releases and updating the single binary automatically. These have the advantage of quick integration and leveraging GitHub as the update distribution channel (no extra servers needed). As your needs evolve, you can introduce more security (signing the releases or even moving to a TUF-based system if warranted). With the above options, you have a spectrum from quick-and-easy solutions to highly secure, complex updaters – you can choose the one that best fits your project’s requirements and your users’ expectations.

**Sources (links):**
- go-selfupdate (GitHub) – Self-update library using GitHub Releases (supports multiple OS/arch assets): https://github.com/creativeprojects/go-selfupdate
- go-rocket-update (GitHub) – Modular self-updater with GitHub provider example: https://github.com/mouuff/go-rocket-update
- blockthrough/selfupdate.go (GitHub) – Toolchain for GitHub release management + self-update (includes signing tools): https://github.com/blockthrough/selfupdate.go
- sanbornm/go-selfupdate (GitHub) – Original Go self-update library with patch support: https://github.com/sanbornm/go-selfupdate
- minio/selfupdate (GitHub) – Fork of go-update with secure update features (checksum, signatures, patching): https://github.com/minio/selfupdate
- fynelabs/selfupdate (GitHub) – Self-update with scheduled checks and Ed25519 signature verification: https://github.com/fynelabs/selfupdate
- Foundries.io blog – Using TUF for a self-updating Go binary (fioctl example): https://foundries.io/insights/blog/tuf-self-updates/

